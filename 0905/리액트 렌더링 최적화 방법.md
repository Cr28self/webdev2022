


# 리액트 렌더링 최적화 방법



## 1. State선언하는 위치를 잘 설계하기
- 해당 state를 사용하는 컴포넌트들 중 가장 최상위 컴포넌트에 state를 선언하는 것이 좋다.
  - 리액트는 특정 state가 변경되면 그 state가 선언된 컴포넌트와 그 하위 컴포넌트들을 모두 리렌더링 시킨다..
  - 이러한 특징 덕분에 state를 사용하지 않는 하위 컴포넌트까지도 불필요하게 리렌더링을 겪게 된다.
> 그래서 State가 선언되는 위치를 잘 설계하는 것이 중요



## 2. 객체 타입의 state는 최대한 분할하여 선언하자.
- 객체가 크면 클수록 분할할 수 있는 만큼 최대한 분할하는 것이 좋다.
  - 일부 state값만 사용하는 하위 컴포넌트가 있다면, 만약 복잡한 객체의 형태를 지는 state중 사용하지 않는 값이 업데이트 되더라도 리랜더링이 발생하므로 비효율적이다.
  - 만약 state를 분할했음에도 이전과 같은 상황이 나타난다 하더라도 코드 내에서 어떤 컴포넌트가 어떤 state값을 사용하는지 쉽게 파악이 가능하기 때문에 더 나은 설계가 가능하다.



## 3. hook에서 shouldComponentUpdate 사용하기 ( React.memo )
- shouldComponentUpdate는 리렌더링 여부를 결정하는 로직을 만드는 LifeCycle 메소드이다. 
  - 이를 이용해 리렌더링을 방지할 수 있기에 렌더링 최적화를 위해서 클래스형 컴포넌트에서 자주 사용되었다.
  - 그러나 함수형 컴포넌트에서는 shouldComponentUpdate를 사용할 수 없으므로 대신 React.memo를 사용한다
> React.memo 는 컴포넌트를 매핑하여 props를 비교하여 리렌데링을 막을 수 있다.

## 4. 컴포넌트 매핑할때 key값으로 index를 사용하지 않기.
- 리액트에서 컴포넌트 매핑할때 반드시 고유 key를 부여하도록 되어있다.
  - 그래서 사람들은 고유 key로 배열의 index를 많이 사용한다
    - 그러나 이러한 방법은 어떤 배열에 중간에 어떤 요소가 삽입되면 삽입된 위치 이후의 요소들이 한칸씩 뒤로 밀리기 때문에 전부 index가 변경된다.
    - 여기서 만약 고유 key를 index로 사용하게 되면 key값이 변경되어 리마운트가 일어나고, 값이 꼬이게 되는 현상이 발생함.


> 그래서 key값을 index대신 고유 id로 사용하게 되면 중간에 어떤 요소가 들어와도 key값이 변경될 위험이 없다.




## 5. useMemo 사용하기
```
const memorizedValue  =  useMemo(  ( ) => f1( param1 ) ,   [deps] );  
```

- 첫번째 파라미터 : 어떻게 연산할지 정의한 함수
- 두번째 파라미터 : deps 배열


    ```
    이 배열 안에 넣은 내용이 바뀌면, 우리가 넣어준 함수를 호출해서 값을 연산해주고, 
    만약에 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용하게 됩니다.
    ```
```
//DemoUseMemo.js

const  DemoUseMemo  =  ()  =>  {
		const  [name, setName] =  useState();

		const  [result, setResult] =  useState(true);
		
		const  changeResult  =  useMemo(()  =>  {
				console.log("UseMemo Use...");
		},  [result]);
		/*UseMemo로 함수 선언 */

		console.log("Not UseMemo");
	
			return  (

			<div>

			<h4>Demo useMemo</h4>

			<div>count: {result}</div>

			<input

			type="text"

			value={name}

			onChange={(e) =>  setName(e.target.value)}

			/>

					<button

					onClick={() =>  {

					setResult(!result);

					}}

			>
	
				Invert

		</button>

	</div>

			);

};

  

export  default  DemoUseMemo;
```
> input부분에 문자 입력할때마다 DemoUseMemo가 렌더링 됨..
> 그러나 changeResult  함수를 Usememo선언함으로써 deps가 변경되지 않는 이상 리랜더링될때 함수가 재정의 되지 않는다.!!

> 최종적으로 메모리제이션된 값을 반환한다


## 5. useCallback 사용

- 상위 컴포넌트의 함수를 props로 하위 컴포넌트로 넘겨줄 때..
	-  만약 상위 컴포넌트가 리렌더링될때 상위 컴포넌트 내 선언된 함수들이 재정의 된다.
		- 그때마다 새 참조 함수를 props로 하위 컴포넌트에 넘겨주게 된다.
			- 이때 props가 달라졌으므로 하위 컴포넌트도 리렌더링 된다.

useCallback으로 선언한 함수는 종속 변수 ( deps )가 변하지 않으면 리렌더링 될때 재정의 되지 않고 이전
참조 변수 그대로 props로 넘겨주게 됨. 

이때 하위 컴포넌트는 이전과 같은 props를 받아서 리렌더링 작업 수행하지 않는다.


> 이러한 원리를 사용해 하위 컴포넌트의 불필요한 리렌더링을  방지 가능하다.


