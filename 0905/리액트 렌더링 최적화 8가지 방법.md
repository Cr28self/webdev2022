

리액트는 특정 state가 변경되면 그 state가 선언된 컴포넌트와 그 하위 컴포넌트들을 모두 리렌더링 시킨다..
이러한 특징 덕분에 state를 사용하지 않는 하위 컴포넌트까지도 불필요하게 리렌더링을 겪게 된다.

그래서 State가 선언되는 위치를 잘 설계하는 것이 중요


해당 state를 사용하는 컴포넌트들 중 가장 최상위 컴포넌트에 state를 선언하는 것이 좋다.
========================================================================


객체 타입의 state는 최대한 분할하여 선언하자.


========================================================================

hook에서 shouldComponentUpdate 사용 ( React.memo )

shouldComponentUpdate는 리렌더링 여부를 결정하는 로직을 만드는 LifeCycle 메소드이다. 
이를 이용해 리렌더링을 방지할 수 있기에 렌더링 최적화를 위해서 클래스형 컴포넌트에서 자주 사용되었다.

그러나 함수형 컴포넌트에서는 shouldComponentUpdate를 사용할 수 없으므로 대신 React.memo를 사용한다.


React.memo 는 컴포넌트를 매핑하여 props를 비교하여 리렌데링을 막을 수 있다.




=======================================================================

컴포넌트 매핑할때 key값으로 index를 사용하지 않기.
리액트에서 컴포넌트 매핑할때 반드시 고유 key를 부여하도록 되어있다.
그래서 사람들은 고유 key로 배열의 index를 많이 사용한다.
그러나 이것은 큰 오류가 있다.
어떤 배열에 중간에 어떤 요소가 삽입되면 삽입된 위치 이후의 요소들이 한칸씩 뒤로 밀리기 때문에 전부 index가 변경된다.
여기서 만약 고유 key를 index로 사용하게 되면 key값이 변경되어 리마운트가 일어나고, 값이 꼬이게 되는 현상이 발생함.


=> 그래서 key값을 index대신 고유 id로 사용하게 되면 중간에 어떤 요소가 들어와도 key값이 변경될 위험이 없다.
=======================================================================
useMemo 사용하기



const func1  =  useMemo(  ( ) => f1( param1 ) ,   [users] );  


useMemo 의 첫번째 파라미터에는 어떻게 연산할지 정의하는 함수를 넣어주면 되고 
두번째 파라미터에는 deps 배열을 넣어주면 되는데, 
이 배열 안에 넣은 내용이 바뀌면, 우리가 넣어준 함수를 호출해서 값을 연산해주고, 
만약에 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용하게 됩니다.



=======================================================================








 











