# Chapter3 — 프로그래밍 언어 설계

## 주요 언어 성공 요인 ( 언어 자체보다는 외적 요인에 의해서.. )

- Lisp
    - 초기 인공지능 분야
- PL/I
    - IBM후원
- Ada
    - 미 국방성 지원
- Pascal
    - 교육용, 마이크로 컴퓨터 표준 언어 역할

---

---

## PL 역사와 주요 언어의 설계 기준 및 목적

### 1950년대

- 초기 설계 기준
    - 실행의 효율성 ( 실행 코드의 압축과 속도 )
    - Fortran언어 설계의 주된 목표였음
- Cobol과 Algol 60의 등장으로 효율성보다 일반적인 원칙 중시
    - Algol 60 : 블록구조, 되부름
        - 사용이 논리적으로
- Cobol
    - 평범한 영어처럼 보이도록 설계함 ( 영어 명령형 문장 형태 )
        - 판독성 향상 목적
            - 최초!
- Algol 60
    - 블록구조 ( begin…end ) , 되부름 사용
        - 분명하고 간결한 알고리즘 표현하기에 적합하여 프로그램 작성력 향상

> Cobol과 Algol 60은 사람과 기계와의 의사소통이 아닌, 사람들간의 의사소통을 위한 언어로 설계
> 

> 따라서.. 판독성, 즉 프로그래머로 하여금 쉽고 정확하게 이해할 수 있도록 하는 언어의 능력 또한 중요한 목표설계가 되었다.
> 

---

### 1960년대 ( 하드웨어 발전 (트랜지스터) , 언어 폭증 시대, 프로그램의 복잡성이 증가됨 )

- 복잡성 제어 필요성 인식
    - 추상화 기법, 배워야 할 언어 규칙과 제한을 줄일 필요성 인식
        - 추상화가 프로그래머에게 프로그래밍 작업의 복잡성을 제어함
        - 언어 규칙과 젱한을 줄이는 것이 문제 정의의 복잡성을 줄임
    - Simula 67
        - class개념 사용
            - 이후 많은 언어들이 제공하는 추상화 기법에 큰 영향
        - 설계 목표로 더욱 강력한 추상화 기법을 제공
    - Algol 68
        - 일반성, 직교성 제공 —> 언어의 복잡성 감소

---

### 1970~80년대 초 ( IC직접회로, 간결성&추상화 강조 )

- C, Pascal, Euclid, Ada, Modula-2 ..
- 언어 구성에 수학적 정의 도입 & 번역기가 번역을 수행할때 프로그램의 **정확성을 증명할 수 있는 기법**을 같춘 언어를 제공
    - 프로그램의 신뢰성을 증진시키려는 시도
- But, 제한된 성공이었음..
    - 증명 시스템이 번역기 자체에 도입되어 추가된 복잡성이 주된 요인이었음

- Pascal
    - 간단한 명령형 언어
    - 하향식 설계 증진 ( Top - down )

---

### 1980년대

- 언어에 논리 또는 수학 개념의 삽입 증진
- 논리를 프로그래밍 언어 자체에 포함
- 함수형 언어에 관심
    - ML, Miranda, Scheme
- 객체 지향 언어에 관심 증가
    - C++

> 시대에 따라 언어의 설계목표가 달라도 여전히 <판독성, 추상화, 복잡성 제어>는 거의 모든 언어 설계 문제에 
포함되어 있는 사항이다.
> 

---

---

---

## 프로그래밍 언어 설계 원칙

### 언어 설계의 기본 원칙 ( 100% 지킬수는 X, 각 원칙끼리 서로 상충함 )

- 효율성
- 일반성
- 직교성
- 획일성

> 4가지 기본원칙에 맞도록 프로그래밍 언어를 만들어야(설계해야)
> 

### 기타 설계 원칙

- 간결성 (simplicity)
- 안전성 (security)
- 표현력 (expressiveness)
- 기존 표기나 규칙과의 일관성
- 정확성 (preciseness)
- 확장성 (extensibility)
- 기계 독립성 (machine independence)
- 제약성 (restrictability), 부분성 (subset)

---

## 효율성 — 언어 설계 기본 원칙 1

**효율성의 기준**에 따라서 분류 가능하다….

### 목적 코드의 효율성  ( 번역해서 만든 기계어 )

- 번역기가 효율적인 실행 코드를 생성할 수 있도록 언어 설계가 이루어져야 한다.
    - < 최적화 >라고 한다. **( code optimization )**
- 예) Pascal에서 상수는 수식으로 표현되지 않음.
- 상수 식별자는 번역과정시 배정된 값으로 대체 ( 코드를 짧고 빠르게 하기 위해 )

### 번역의 효율성 ( 번역기 )

- 적절한 크기의 번역기로 빠르게 번역할 수 있는 것
- 예) 언어 번역의 단계 구성 문제 (Pascal : 1-pass, Modula-2 : 2-pass)
    - 가끔 언어 설계는 실행 시간에 수행해야 될 검사를 번역 시간에 수행하기 위하여 매우 어려운 규칙 일부를 포함하기도 한다..
        - Algol 68의 허상 참조 ( dangling reference )가 발생하지 못하도록 한 규칙
    - 오류 검사 → 불확실한 효율성 문제가 될 수 있음
        - 번역시간에 오류 검사하는 것
            - 번역기가 비효율적일수 있다.
        - 실행 시간에 오류 검사하는 것
            - 목적 코드가 비효율적일 수 있다..
        - But, 오류  검사를 무시한는 것은…
            - 또다른 설계 원칙인 <신뢰성>을 떨어뜨리는 결과를 초래
                - 신뢰성 : 프로그램이 실행시에 예상치 못한 행동을 하거나 재해를 주는 방향으로 행동하지 못하도록 하는..

### 구현의 효율성

- 번역기의 효율적 작성 가능 여부
- 예) 번역기 구현의 어려움, 번역 수행 알고리즘의 충분치 못한 이해로 실패한 언어 (Algol 60)
    - Ada의 크기와 복잡성이 컴파일러 개발에 장애가 되었으며, 그로 인해 Ada의 사용이 해를 입음

### 프로그래밍 효율성 ( 언어를 통해서 작성할때 얼마나 빠르고 쉽게 작성 가능한지, 
프로그램의 작성력 )

- 프로그램 작성의 단순성, 용이성 문제
- 언어의 표현성, 추상화 메커니즘과 관련
    - 표현력 : 복잡한 과정과 구조를 쉽게 표현
        - 언어의 <추상화 지원>, <일반성>에 관계된다.
- 이상적인 언어 — Lisp, Prolog
    - 구문의 간결성 or 변수 선언 등과 같은 불필요한 세부적인 것을 피하는 것이 
    프로그래밍 효율에 있어서 중요한 요소로 보는 관점에 의해..
    - 물론 이러한 효율은 <판독성>, <실행의 효율성>, <신뢰성>과 같은 다른 언어 설계 원칙과 상충될 수 있음

> 실제 신뢰성은 효율성 문제 자체로 간주되기도 한다..
( 효율성은 신뢰도와 관계됨 ) ( 신뢰도 up → 효율성 up )
> 
- 신뢰가 없는 프로그램
    - 많은 비용 낭비
        - 수정할때 오류가 나는 행동 제거, 여분 테스트 시간, 오류로 인한 효과 수정하는 데 걸리는 시간 낭비
        - 개발과 코딩 시간을 낭비하는 결과를 초래하게 된다!!!
        - 이러한 종류의 효율성은 SW공학에서의 자원 소비 쟁점이다..
            - **이런 의미에서 생성된 SW의 효율성**은 **<판독성>**과 **<유지보수>**에 크게 좌우된다.
            - 프로그램 작성은 덜 중요시 된다.
            - SW기술자는 코딩시간보다 디버깅, 유지보수에 더 많은 시간이 필요하다고 평가함

> 궁극적으로, 판독성과 유지 보수 능력은 효율성에 관한 매우 중요한 쟁점이다.
> 

---

---

---

## 일반성, 직교성, 획일성

- 3가지 개념 전부 밀접하게 관련있다.
- 3가지 개념 전부 간결성은 보장하지 못한다.

### 일반성

- 특별한 경우를 피하거나 밀접한 관련의 여러 개념들을 하나의 개념으로 결합

### PL에서 일반성이 부족한 예시

- Pascal : 프로시저 선언과 프로시저를 매개 변수로 제공함
    - But, 프로시저형 변수는 없다. —> 일반성 부족!!!
    - 프로시저를 자료형처럼 선언했으면 **변수도 프로시저형 선언이 가능해야**
        - 프로시저 표현에 대한 일반성을 갖는 것!!